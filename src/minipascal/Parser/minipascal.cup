package minipascal.Parser;

import java_cup.runtime.*;
import tree.Node;

parser code {:
  public void unrecovered_syntax_error(Symbol s) {
    String msg = String.format(
      "No se pudo recuperar del error en la linea %d, columna %d.\nNo se esperaba el token %s!",
      s.left,
      s.right,
      sym.terminalNames[s.sym]
    );
    System.out.println(msg);
  }
:}

terminal FUNCTION;
terminal PROCEDURE;
terminal INTEGER;
terminal REAL;
terminal BOOLEAN;
terminal CHAR;
terminal STRING;
terminal RECORD;
terminal PROGRAM;
terminal IF;
terminal THEN;
terminal ELSE;
terminal CONST;
terminal VAR;
terminal BEGIN;
terminal END;
terminal WHILE;
terminal DO;
terminal FOR;
terminal TO;
terminal REPEAT;
terminal UNTIL;
terminal FUNC_READ;
terminal FUNC_WRITE;
terminal ASIGNACION;
terminal PAR_IZQ;
terminal PAR_DER;
terminal COMA;
terminal PUNTO;
terminal PUNTOCOMA;
terminal DOSPUNTOS;
terminal OR;
terminal AND;
terminal NOT;
terminal String OP_RELACIONAL;
terminal String OP_SUMA;
terminal String OP_MULT;
terminal String ID;
terminal Float NUM_FLOAT;
terminal Integer NUM_INTEGER;
terminal Character CONSTCHAR;
terminal String CONSTSTR;
terminal Boolean CONSTBOOL;
terminal Object NIL;

terminal ARRAY, BREAK, CASE,CONTINUE, DOWNTO, IN, XOR, DIV, QUOTE, MOD,
 FILE, PACKED, FORWARD;

non terminal S;
non terminal PROGRAM_BLOCK;
non terminal VAR_BLOCK;
non terminal VARS;
non terminal ARGS;
non terminal IDS;
non terminal TYPES;
non terminal FUNC_PROC_BLOCK;
non terminal FUNC_DECL;
non terminal PROC_DECL;
non terminal MAIN_BLOCK;
non terminal STMNT_FUNC;
non terminal STMNT_LIST;
non terminal STATEMENT;
non terminal COMPOUND_STATEMENT;
non terminal CONST_VAL;
non terminal EXPR;
non terminal SIMPLE_EXPR;
non terminal EXPR_LIST;
non terminal TERMINO;
non terminal FACTOR;
non terminal OPEN_STATEMENT;
non terminal CLOSED_STATEMENT;
non terminal SIMPLE_STATEMENT;
non terminal WHILE_BLOCK;
non terminal FOR_BLOCK;
non terminal REPEAT_BLOCK;
non terminal INICIO;

start with S;

S ::= INICIO: inicio {: System.out.println(inicio); :}
  ;

INICIO ::=
  PROGRAM_BLOCK: program
  VAR_BLOCK: var
  FUNC_PROC_BLOCK: functions
  MAIN_BLOCK: main
  {:
    // program es obligatorio, seria la raiz
    Node raiz = new Node<>(program);

    // var es opcional
    if (var != null) {
      raiz.add(var);
    }

    // functions es opcional
    if (functions != null) {
      raiz.add(functions);
    }

    // main es opcional ("begin end.")
    if (main != null) {
      raiz.add(main);
    }

    RESULT = raiz;
  :}
  ;

PROGRAM_BLOCK ::=
  PROGRAM ID: id PUNTOCOMA {: RESULT = id; :}
  ;

FUNC_PROC_BLOCK ::=
  FUNC_DECL FUNC_PROC_BLOCK
  | PROC_DECL FUNC_PROC_BLOCK
  |
  ;

FUNC_DECL ::=
  FUNCTION ID PAR_IZQ ARGS PAR_DER DOSPUNTOS TYPES PUNTOCOMA
  VAR_BLOCK
  BEGIN
    STMNT_LIST
  END PUNTOCOMA
  ;

PROC_DECL ::=
  PROCEDURE ID PAR_IZQ ARGS PAR_DER PUNTOCOMA
  VAR_BLOCK
  BEGIN
    STMNT_LIST
  END PUNTOCOMA
  ;

VAR_BLOCK ::=
  VAR VARS: vars {: Node temp = new Node<>(vars);  RESULT = temp; :}
  |
  ;

VARS ::=
  IDS DOSPUNTOS TYPES PUNTOCOMA VARS
  | IDS DOSPUNTOS TYPES PUNTOCOMA
  ;

ARGS ::=
  IDS DOSPUNTOS TYPES PUNTOCOMA ARGS
  | IDS DOSPUNTOS TYPES
  |
  ;

IDS ::=
  ID COMA IDS
  | ID
  ;

TYPES ::= INTEGER
  | REAL
  | BOOLEAN
  | CHAR
  | STRING
  ;

MAIN_BLOCK ::=
  BEGIN STMNT_LIST: stmtList END PUNTO {: /* Node temp = new Node<>(stmtList); */ RESULT = stmtList; :}
  ;

STMNT_LIST ::=
  STATEMENT PUNTOCOMA STMNT_LIST
  |
  ;

STMNT_FUNC ::=
  ID PAR_IZQ EXPR_LIST PAR_DER
  | FUNC_READ PAR_IZQ EXPR_LIST PAR_DER
  | FUNC_WRITE PAR_IZQ EXPR_LIST PAR_DER
  ;

STATEMENT ::=
  | OPEN_STATEMENT
  | IF EXPR THEN CLOSED_STATEMENT ELSE CLOSED_STATEMENT
  | WHILE_BLOCK
  | FOR_BLOCK
  | REPEAT_BLOCK
  | COMPOUND_STATEMENT
  | SIMPLE_STATEMENT
  ;

COMPOUND_STATEMENT ::=
  BEGIN STMNT_LIST END
  ;

SIMPLE_STATEMENT ::=
  ID ASIGNACION EXPR
  | STMNT_FUNC
  ;

OPEN_STATEMENT ::=
  IF EXPR THEN STATEMENT
  | IF EXPR THEN CLOSED_STATEMENT ELSE OPEN_STATEMENT
  ;

CLOSED_STATEMENT ::=
  IF EXPR THEN CLOSED_STATEMENT ELSE CLOSED_STATEMENT
  | SIMPLE_STATEMENT
  ;

WHILE_BLOCK ::=
  WHILE EXPR DO STATEMENT
  ;

FOR_BLOCK ::=
  FOR ID ASIGNACION EXPR TO NUM_INTEGER DO STATEMENT
  ;

REPEAT_BLOCK ::=
  REPEAT STMNT_LIST UNTIL EXPR
  ;

EXPR ::=
  SIMPLE_EXPR
  | SIMPLE_EXPR OP_RELACIONAL SIMPLE_EXPR
  ;

EXPR_LIST ::=
  EXPR: expr COMA EXPR_LIST: exprList
  | EXPR: expr {: RESULT = expr; :}
  ;

SIMPLE_EXPR ::=
  TERMINO: termino {: RESULT = termino; :}
  | OP_SUMA: opSuma TERMINO: termino {: Node op = new Node<>(opSuma); op.add(termino); RESULT = op; :}
  | SIMPLE_EXPR: simpleExpr OP_SUMA: opSuma TERMINO: termino
  {:
    Node op = new Node<>();
    op.add(simpleExpr);
    op.add(termino);
    RESULT = op;
  :}
  ;

TERMINO ::=
  FACTOR: factor {: RESULT = factor; :}
  | TERMINO: termino OP_MULT: opMult FACTOR: factor
  {:
    Node mult = new Node<>(opMult);
    mult.add(termino);
    mult.add(factor);
    RESULT = mult;
  :}
  ;

FACTOR ::=
  ID: id {: RESULT = new Node<>(id); :}
  | STMNT_FUNC: stmntFunc {: RESULT = new Node<>(stmntFunc); :}
  | CONST_VAL: val {: RESULT = new Node<>(val); :}
  | PAR_IZQ EXPR: expr PAR_DER {: RESULT = new Node<>(expr); :}
  | NOT: not FACTOR: factor {: Node not = new Node<>(not); not.add(factor); RESULT = not; :}
  ;

CONST_VAL ::=
  NUM_INTEGER: num {: RESULT = num; :}
  | NUM_FLOAT: num {: RESULT = num; :}
  | CONSTCHAR: constchar {: RESULT = constchar; :}
  | CONSTSTR: string {: RESULT = string; :}
  | CONSTBOOL: bool {: RESULT = bool; :}
  | NIL: nil {: RESULT = null; :}
  ;
