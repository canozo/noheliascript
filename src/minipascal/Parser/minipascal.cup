package minipascal.Parser;

import java_cup.runtime.*;
import tree.*;


parser code {:
    public Init root = null;

:}



non terminal S;
terminal NIL;
terminal FUNCTION;
terminal PROCEDURE;
terminal INTEGER;
terminal REAL;
terminal BOOLEAN;
terminal CHAR;
terminal STRING;
terminal RECORD;
terminal PROGRAM;
terminal IF;
terminal THEN;
terminal ELSE;
terminal CONST;
terminal VAR;
terminal BEGIN;
terminal END;
terminal WHILE;
terminal DO;
terminal FOR;
terminal TO;
terminal REPEAT;
terminal UNTIL;
terminal Boolean CONSTBOOL;
terminal FUNC_READ;
terminal FUNC_WRITE;
terminal ASIGNACION;
terminal PAR_IZQ;
terminal PAR_DER;
terminal COMA;
terminal PUNTO;
terminal PUNTOCOMA;
terminal DOSPUNTOS;
terminal OR;
terminal AND;
terminal NOT;
terminal String OP_RELACIONAL;
terminal String OP_SUMA;
terminal String OP_MULT;
terminal String ID;
terminal Float NUM_FLOAT;
terminal Integer NUM_INTEGER;
terminal Character CONSTCHAR;
terminal String CONSTSTR;

terminal ARRAY, BREAK, CASE,CONTINUE, DOWNTO, IN, XOR, DIV, QUOTE, MOD,
 FILE, PACKED, FORWARD;

non terminal PROGRAM_BLOCK;
non terminal VAR_BLOCK;
non terminal VARS;
non terminal ARGS;
non terminal IDS;
non terminal TYPES;
non terminal FUNC_PROC_BLOCK;
non terminal FUNC_DECL;
non terminal PROC_DECL;
non terminal MAIN_BLOCK;
non terminal STMNT_FUNC;
non terminal STMNT_LIST;
non terminal STATEMENT;
non terminal COMPOUND_STATEMENT;
non terminal CONST_VAL;
non terminal EXPR;
non terminal SIMPLE_EXPR;
non terminal EXPR_LIST;
non terminal TERMINO;
non terminal FACTOR;
non terminal BUILT_IN;
non terminal OPEN_STATEMENT;
non terminal CLOSED_STATEMENT;
non terminal SIMPLE_STATEMENT;
non terminal WHILE_BLOCK;
non terminal FOR_BLOCK;
non terminal REPEAT_BLOCK;
non terminal INICIO;

start with S;

S::= INICIO:inicio{:
    Init i = new Init( "start");
    parser.root = i;
    RESULT = i;


:}
    ;

INICIO ::=
  PROGRAM_BLOCK
  VAR_BLOCK
  FUNC_PROC_BLOCK
  MAIN_BLOCK
  ;

PROGRAM_BLOCK ::=
  PROGRAM:program ID:id PUNTOCOMA:punco {:
        ProgramBlock pbr = new ProgramBlock((String) id);
        RESULT = pbr;
        :}
  ;

FUNC_PROC_BLOCK ::=
  FUNC_DECL:fd FUNC_PROC_BLOCK:fpb {:
        //FunctionProcedure fp = new FunctionProcedure((FunctionDeclaration)fd, (FunctionProcedure) fpb);
        //RESULT = fp;
  :}
  | PROC_DECL:pd FUNC_PROC_BLOCK:fpb{:
        //FunctionProcedure fp = new FunctionProcedure(()pd, fpb, "");
        //RESULT = fp;
  :}
  |
  ;

FUNC_DECL ::=
  FUNCTION ID PAR_IZQ ARGS PAR_DER DOSPUNTOS TYPES PUNTOCOMA
  VAR_BLOCK
  BEGIN
    STMNT_LIST
  END PUNTOCOMA
  ;

PROC_DECL ::=
  PROCEDURE ID PAR_IZQ ARGS PAR_DER PUNTOCOMA
  VAR_BLOCK
  BEGIN
    STMNT_LIST
  END PUNTOCOMA
  ;

VAR_BLOCK ::=
  VAR VARS
  |
  ;

VARS ::=
  IDS DOSPUNTOS TYPES PUNTOCOMA VARS
  | IDS DOSPUNTOS TYPES PUNTOCOMA
  ;

ARGS ::=
  IDS DOSPUNTOS TYPES PUNTOCOMA ARGS
  | IDS DOSPUNTOS TYPES
  |
  ;

IDS ::=
  ID COMA IDS
  | ID
  ;

TYPES ::= INTEGER
  | REAL
  | BOOLEAN
  | CHAR
  | STRING
  ;

MAIN_BLOCK ::=
  BEGIN STMNT_LIST END PUNTO
  ;

STMNT_LIST ::=
  STATEMENT PUNTOCOMA STMNT_LIST
  |
  ;

STMNT_FUNC ::=
  ID PAR_IZQ EXPR_LIST PAR_DER
  | BUILT_IN PAR_IZQ EXPR_LIST PAR_DER
  ;

STATEMENT ::=
  | OPEN_STATEMENT
  | IF EXPR THEN CLOSED_STATEMENT ELSE CLOSED_STATEMENT
  | WHILE_BLOCK
  | FOR_BLOCK
  | REPEAT_BLOCK
  | COMPOUND_STATEMENT
  | SIMPLE_STATEMENT
  ;

COMPOUND_STATEMENT ::=
  BEGIN STMNT_LIST END
  ;

SIMPLE_STATEMENT ::=
  ID ASIGNACION EXPR
  | STMNT_FUNC
  ;

OPEN_STATEMENT ::=
  IF EXPR THEN STATEMENT
  | IF EXPR THEN CLOSED_STATEMENT ELSE OPEN_STATEMENT
  ;

CLOSED_STATEMENT ::=
  IF EXPR THEN CLOSED_STATEMENT ELSE CLOSED_STATEMENT
  | SIMPLE_STATEMENT
  ;

WHILE_BLOCK ::=
  WHILE EXPR DO STATEMENT
  ;

FOR_BLOCK ::=
  FOR ID ASIGNACION EXPR TO NUM_INTEGER DO STATEMENT
  ;

REPEAT_BLOCK ::=
  REPEAT STMNT_LIST UNTIL EXPR
  ;

EXPR ::=
  SIMPLE_EXPR
  | SIMPLE_EXPR OP_RELACIONAL SIMPLE_EXPR
  ;

EXPR_LIST ::=
  EXPR COMA EXPR_LIST
  | EXPR
  ;

SIMPLE_EXPR ::=
  TERMINO
  | OP_SUMA TERMINO
  | SIMPLE_EXPR OP_SUMA TERMINO
  ;

TERMINO ::=
  FACTOR
  | TERMINO OP_MULT FACTOR
  ;

FACTOR ::=
  ID:id{:
        Factor fac = new Factor((String)id);
        RESULT = fac;
  :}
  | STMNT_FUNC
  | CONST_VAL
  | PAR_IZQ EXPR PAR_DER
  | NOT:no FACTOR:fact{:
        Factor fac = new Factor((String)no, (Factor)fact);
        RESULT = fac;
  :}
  ;

BUILT_IN ::=
  FUNC_WRITE:fw{:
        BuiltIn bi = new BuiltIn((String) fw);
        RESULT = bi;
  :}
  | FUNC_READ:fr{:
        BuiltIn bi = new BuiltIn((String)fr);
        RESULT = bi;
  :}
  ;

CONST_VAL ::=
  NUM_INTEGER:numInt{:
        ConstantValue cv = new ConstantValue( Integer.toString(numInt));
        RESULT = cv;
  :}
  | NUM_FLOAT:numFloat{:
         ConstantValue cv = new ConstantValue(Float.toString(numFloat) );
         RESULT= cv;
   :}
  | CONSTCHAR:constChar{:
         ConstantValue cv = new ConstantValue(Character.toString(constChar) );
         RESULT =cv;
   :}
  | CONSTSTR:consStr{:
         ConstantValue cv = new ConstantValue(consStr);
         RESULT =cv;
   :}
  | CONSTBOOL:numBool{:
          ConstantValue cv = new ConstantValue(Boolean.toString(numBool) );
          RESULT =cv;
    :}
  | NIL:constNil{:
        ConstantValue cv = new ConstantValue((String) constNil);
        RESULT =cv;
  :}
  ;
