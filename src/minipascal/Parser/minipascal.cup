package minipascal.Parser;

import java_cup.runtime.*;
import java.util.List;
import tree.*;

parser code {:
  private static final boolean DEBUG = false;
  private boolean ERROR = false;

  public void syntax_error(Symbol s) {
    List<Integer> expected = expected_token_ids();
    StringBuffer expStr = new StringBuffer();

    for (Integer id : expected) {
      if (id != 1) {
        expStr.append(sym.terminalNames[id] + " ");
      }
    }

    String msg = String.format(
      "Error de sintaxis en la linea %d, columna %d.\nNo se esperaba el token %s!\nSe esperaba uno de los siguientes: %s\n",
      s.left,
      s.right,
      sym.terminalNames[s.sym],
      expStr
    );
    System.out.println(msg);
  }

  public void unrecovered_syntax_error(Symbol s) {
    System.out.println("No se puede recuperar del error!");
  }
:}

terminal FUNCTION;
terminal PROCEDURE;
terminal INTEGER;
terminal REAL;
terminal BOOLEAN;
terminal CHAR;
terminal STRING;
terminal PROGRAM;
terminal IF;
terminal THEN;
terminal ELSE;
terminal VAR;
terminal BEGIN;
terminal END;
terminal WHILE;
terminal DO;
terminal FOR;
terminal TO;
terminal REPEAT;
terminal UNTIL;
terminal FUNC_READ;
terminal FUNC_WRITE;
terminal ASIGNACION;
terminal PAR_IZQ;
terminal PAR_DER;
terminal COMA;
terminal PUNTO;
terminal PUNTOCOMA;
terminal DOSPUNTOS;
terminal NOT;
terminal OR;
terminal AND;
terminal RECORD;
terminal String OP_RELACIONAL;
terminal String OP_SUMA;
terminal String OP_MULT;
terminal String ID;
terminal Double NUM_DOUBLE;
terminal Integer NUM_INTEGER;
terminal Character CONSTCHAR;
terminal String CONSTSTR;
terminal Boolean CONSTBOOL;
terminal Object NIL;
terminal String UNKNOWN;

non terminal S;
non terminal PROGRAM_BLOCK;
non terminal VAR_BLOCK;
non terminal VARS;
non terminal ARGS;
non terminal MAYBE_ARGS;
non terminal IDS;
non terminal TYPE;
non terminal FUNC_PROC_BLOCK;
non terminal FUNC_DECL;
non terminal PROC_DECL;
non terminal MAIN_BLOCK;
non terminal STMNT_FUNC;
non terminal STMNT_LIST;
non terminal STATEMENT;
non terminal COMPOUND_STATEMENT;
non terminal CONST_VAL;
non terminal EXPR;
non terminal SIMPLE_EXPR;
non terminal EXPR_LIST;
non terminal TERMINO;
non terminal FACTOR;
non terminal OPEN_STATEMENT;
non terminal CLOSED_STATEMENT;
non terminal SIMPLE_STATEMENT;
non terminal WHILE_BLOCK;
non terminal FOR_BLOCK;
non terminal REPEAT_BLOCK;
non terminal INICIO;

start with S;

S ::=
  INICIO: inicio
  {:
    System.out.println(inicio);
    if (DEBUG) {
      ((Node) inicio).visit();
    }
  :}
  ;

INICIO ::=
  PROGRAM_BLOCK: program
  VAR_BLOCK: maybeVar
  FUNC_PROC_BLOCK: maybeFuncs
  MAIN_BLOCK: maybeMain
  {:
    // program es obligatorio, seria la raiz
    Node raiz = (NProgram) program;

    // var es opcional
    if (maybeVar != null) {
      raiz.add((NVars) maybeVar);
    }

    // functions y procedures son opcionales
    if (maybeFuncs != null) {
      raiz.add((NFuncProcList) maybeFuncs);
    }

    // main
    raiz.add((NMain) maybeMain);

    RESULT = raiz;
  :}
  ;

PROGRAM_BLOCK ::=
  PROGRAM: program ID: id PUNTOCOMA
  {: RESULT = new NProgram(id); :}
  ;

FUNC_PROC_BLOCK ::=
  FUNC_DECL: func FUNC_PROC_BLOCK: maybeMore
  {:
    Node res = new NFuncProcList((Node) func);
    if (maybeMore != null) {
      res.join((NFuncProcList) maybeMore);
    }
    RESULT = res;
  :}
  | PROC_DECL: proc FUNC_PROC_BLOCK: maybeMore
  {:
    Node res = new NFuncProcList((Node) proc);
    if (maybeMore != null) {
      res.join((NFuncProcList) maybeMore);
    }
    RESULT = res;
  :}
  |
  | error FUNC_PROC_BLOCK {: ERROR = true; :}
  ;

FUNC_DECL ::=
  FUNCTION ID: id PAR_IZQ MAYBE_ARGS: maybeArgs PAR_DER DOSPUNTOS TYPE: returnType PUNTOCOMA
  VAR_BLOCK: maybeVars
  COMPOUND_STATEMENT: maybeStmntList
  PUNTOCOMA
  {:
//     TODO quitar esto, solo sirve para el print del json
    String nid = String.format("\"%s\"", (String) ((Node) returnType).data);
    RESULT = new NFunction(
      new NID(id),
//      (Node) returnType,
      new NType(nid),
      (Node) maybeArgs,
      (Node) maybeVars,
      (Node) maybeStmntList
    );
  :}
  ;

PROC_DECL ::=
  PROCEDURE ID: id PAR_IZQ MAYBE_ARGS: maybeArgs PAR_DER PUNTOCOMA
  VAR_BLOCK: maybeVars
  COMPOUND_STATEMENT: maybeStmntList
  PUNTOCOMA
  {:
    RESULT = new NProcedure(
      new NID(id),
      (Node) maybeArgs,
      (Node) maybeVars,
      (Node) maybeStmntList
    );
  :}
  ;

VAR_BLOCK ::=
  VAR VARS: vars
  {: RESULT = vars; :}
  |
  ;

VARS ::=
  IDS: ids DOSPUNTOS TYPE: type PUNTOCOMA VARS: moreVars
  {:
    Node res = new NVars((Node) type, (Node) ids);
    res.join((NVars) moreVars);
    RESULT = res;
  :}
  | IDS: ids DOSPUNTOS TYPE: type PUNTOCOMA
  {: RESULT = new NVars((Node) type, (Node) ids); :}
  ;

MAYBE_ARGS ::=
  ARGS: args
  {: RESULT = args; :}
  |
  ;

ARGS ::=
  IDS: ids DOSPUNTOS TYPE: type PUNTOCOMA ARGS: moreArgs
  {:
    Node res = new NArgs((Node) type, (Node) ids);
    res.join((NArgs) moreArgs);
    RESULT = res;
  :}
  | IDS: ids DOSPUNTOS TYPE: type
  {: RESULT = new NArgs((Node) type, (Node) ids); :}
  ;

IDS ::=
  ID: id COMA IDS: ids
  {:
    Node res = new NIDList(new NID(id));
    if (ids instanceof NIDList) {
      res.join((NIDList) ids);
    } else {
      res.add((Node) ids);
    }
    RESULT = res;
  :}
  | ID: id
  {: RESULT = new NID(id); :}
  ;

TYPE ::=
  INTEGER
  {: RESULT = new NType("integer"); :}
  | REAL
  {: RESULT = new NType("real"); :}
  | BOOLEAN
  {: RESULT = new NType("boolean"); :}
  | CHAR
  {: RESULT = new NType("char"); :}
  | STRING
  {: RESULT = new NType("string"); :}
  ;

MAIN_BLOCK ::=
  COMPOUND_STATEMENT: maybeStmntList PUNTO
  {: RESULT = new NMain((Node) maybeStmntList); :}
  ;

STMNT_LIST ::=
  STATEMENT: stmnt PUNTOCOMA STMNT_LIST: stmntList
  {:
    Node list = new NStmntList((Node) stmnt);
    if (stmntList != null) {
      list.join((NStmntList) stmntList);
    }
    RESULT = list;
  :}
  |
//  | STATEMENT: stmnt error STMNT_LIST: stmntList {: ERROR = true; :}
  ;

STMNT_FUNC ::=
  ID: id PAR_IZQ EXPR_LIST: exprList PAR_DER
  {: RESULT = new NFuncCall(id, (Node) exprList); :}
  | FUNC_READ PAR_IZQ EXPR_LIST: exprList PAR_DER
  {: RESULT = new NFuncRead((Node) exprList); :}
  | FUNC_WRITE PAR_IZQ EXPR_LIST: exprList PAR_DER
  {: RESULT = new NFuncWrite((Node) exprList); :}
  ;

STATEMENT ::=
  | OPEN_STATEMENT: stmnt
  {: RESULT = stmnt; :}
  | IF EXPR: ifExpr THEN CLOSED_STATEMENT: thenStmnt ELSE CLOSED_STATEMENT: elseStmnt
  {: RESULT = new NIfElse((Node) ifExpr, (Node) thenStmnt, (Node) elseStmnt); :}
  | WHILE_BLOCK: w
  {: RESULT = w; :}
  | FOR_BLOCK: f
  {: RESULT = f; :}
  | REPEAT_BLOCK: r
  {: RESULT = r; :}
  | SIMPLE_STATEMENT: s
  {: RESULT = s; :}
  ;

COMPOUND_STATEMENT ::=
  BEGIN STMNT_LIST: stmntList END
  {:
    if (stmntList != null) {
      RESULT = new NBegin((Node) stmntList);
    }
  :}
  | BEGIN error {: ERROR = true; :}
  ;

SIMPLE_STATEMENT ::=
  ID: id ASIGNACION EXPR: expr
  {: RESULT = new NAssign(new NID(id), (Node) expr); :}
  | STMNT_FUNC: stmntFunc
  {: RESULT = stmntFunc; :}
  | COMPOUND_STATEMENT: c
  {: RESULT = c; :}
  ;

OPEN_STATEMENT ::=
  IF EXPR: ifExpr THEN STATEMENT: thenStmnt
  {: RESULT = new NIfElse((Node) ifExpr, (Node) thenStmnt); :}
  | IF EXPR: ifExpr THEN CLOSED_STATEMENT: thenStmnt ELSE OPEN_STATEMENT: elseStmnt
  {: RESULT = new NIfElse((Node) ifExpr, (Node) thenStmnt, (Node) elseStmnt); :}
  ;

CLOSED_STATEMENT ::=
  IF EXPR: ifExpr THEN CLOSED_STATEMENT: thenStmnt ELSE CLOSED_STATEMENT: elseStmnt
  {: RESULT = new NIfElse((Node) ifExpr, (Node) thenStmnt, (Node) elseStmnt); :}
  | SIMPLE_STATEMENT: simpleStmnt
  {: RESULT = simpleStmnt; :}
  ;

WHILE_BLOCK ::=
  WHILE EXPR: whileExpr DO STATEMENT: doStmnt
  {: RESULT = new NWhile((Node) whileExpr, (Node) doStmnt); :}
  | WHILE error STATEMENT {: ERROR = true; :}
  ;

FOR_BLOCK ::=
  FOR ID: id ASIGNACION: asign EXPR: expr TO FACTOR: toFactor DO STATEMENT: doStmnt
  {: RESULT = new NFor(new NAssign(new NID(id), (Node) expr), (Node) toFactor, (Node) doStmnt); :}
  | FOR error STATEMENT {: ERROR = true; :}
  ;

REPEAT_BLOCK ::=
  REPEAT STMNT_LIST: stmntList UNTIL EXPR: expr
  {: RESULT = new NRepeat((Node) stmntList, (Node) expr); :}
  | REPEAT STMNT_LIST error {: ERROR = true; :}
  ;

EXPR_LIST ::=
  EXPR: expr COMA EXPR_LIST: exprList
  {:
    Node list = new NExprList((Node) expr);
    if (exprList instanceof NExprList) {
      list.join((NExprList) exprList);
    } else {
      list.add((Node) exprList);
    }
    RESULT = list;
  :}
  | EXPR: expr
  {: RESULT = expr; :}
  ;

EXPR ::=
  SIMPLE_EXPR: simpleExpr
  {: RESULT = simpleExpr; :}
  | SIMPLE_EXPR: simpleExpr1 OR SIMPLE_EXPR: simpleExpr2
  {: RESULT = new NOr((Node) simpleExpr1, (Node) simpleExpr2); :}
  | error {: ERROR = true; :}
  ;

SIMPLE_EXPR ::=
  TERMINO: termino
  {: RESULT = termino; :}
  | OP_SUMA: op TERMINO: termino
  {: RESULT = new NSuma(op, (Node) termino); :}
  | SIMPLE_EXPR: simpleExpr OP_SUMA: op TERMINO: termino
  {: RESULT = new NSuma((Node) simpleExpr, op, (Node) termino); :}
  | TERMINO: termino1 AND TERMINO: termino2
  {: RESULT = new NAnd((Node) termino1, (Node) termino2); :}
  ;

TERMINO ::=
  FACTOR: factor
  {: RESULT = factor; :}
  | TERMINO: termino OP_MULT: op FACTOR: factor
  {: RESULT = new NMult((Node) termino, op, (Node) factor); :}
  | FACTOR: factor1 OP_RELACIONAL: op FACTOR: factor2
  {: RESULT = new NOpRel((Node) factor1, op, (Node) factor2); :}
  ;

FACTOR ::=
  ID: id
  {: RESULT = new NID(id); :}
  | STMNT_FUNC: stmntFunc
  {: RESULT = stmntFunc; :}
  | CONST_VAL: val
  {: RESULT = val; :}
  | PAR_IZQ EXPR: expr PAR_DER
  {: RESULT = expr; :}
  | NOT: n FACTOR: factor
  {: RESULT = new NNot((Node) factor); :}
  ;

CONST_VAL ::=
  NUM_INTEGER: num
  {: RESULT = new NInteger(num); :}
  | NUM_DOUBLE: num
  {: RESULT = new NDouble(num); :}
  | CONSTCHAR: constchar
  {: RESULT = new NChar(constchar); :}
  | CONSTSTR: string
  {: RESULT = new NString(string); :}
  | CONSTBOOL: bool
  {: RESULT = new NBool(bool); :}
  | NIL: nil
  {: RESULT = new NNil(); :}
  ;
