package minipascal.Parser;

import java_cup.runtime.*;
import java.util.List;
import tree.Node;

// TODO implementar un visitor para todos los nodos

parser code {:
    public void syntax_error(Symbol s) {
      List<Integer> expected = expected_token_ids();
      StringBuffer expStr = new StringBuffer();

      for (Integer id : expected) {
        expStr.append(sym.terminalNames[id] + " ");
      }

      String msg = String.format(
        "Error de sintaxis en la linea %d, columna %d.\nNo se esperaba el token %s!\nSe esperaba uno de los siguientes: %s",
        s.left,
        s.right,
        sym.terminalNames[s.sym],
        expStr
      );
      System.out.println(msg);
    }

  public void unrecovered_syntax_error(Symbol s) {
    System.out.println("No se puede recuperar del error!");
  }
:}

terminal FUNCTION;
terminal PROCEDURE;
terminal INTEGER;
terminal REAL;
terminal BOOLEAN;
terminal CHAR;
terminal STRING;
terminal PROGRAM;
terminal IF;
terminal THEN;
terminal ELSE;
terminal VAR;
terminal BEGIN;
terminal END;
terminal WHILE;
terminal DO;
terminal FOR;
terminal TO;
terminal REPEAT;
terminal UNTIL;
terminal FUNC_READ;
terminal FUNC_WRITE;
terminal ASIGNACION;
terminal PAR_IZQ;
terminal PAR_DER;
terminal COMA;
terminal PUNTO;
terminal PUNTOCOMA;
terminal DOSPUNTOS;
terminal NOT;
terminal OR;
terminal AND;
terminal RECORD;
terminal String OP_RELACIONAL;
terminal String OP_SUMA;
terminal String OP_MULT;
terminal String ID;
terminal Float NUM_FLOAT;
terminal Integer NUM_INTEGER;
terminal Character CONSTCHAR;
terminal String CONSTSTR;
terminal Boolean CONSTBOOL;
terminal Object NIL;

non terminal S;
non terminal PROGRAM_BLOCK;
non terminal VAR_BLOCK;
non terminal VARS;
non terminal ARGS;
non terminal MAYBE_ARGS;
non terminal IDS;
non terminal TYPE;
non terminal FUNC_PROC_BLOCK;
non terminal FUNC_DECL;
non terminal PROC_DECL;
non terminal MAIN_BLOCK;
non terminal STMNT_FUNC;
non terminal STMNT_LIST;
non terminal STATEMENT;
non terminal COMPOUND_STATEMENT;
non terminal CONST_VAL;
non terminal EXPR;
non terminal SIMPLE_EXPR;
non terminal EXPR_LIST;
non terminal TERMINO;
non terminal FACTOR;
non terminal OPEN_STATEMENT;
non terminal CLOSED_STATEMENT;
non terminal SIMPLE_STATEMENT;
non terminal WHILE_BLOCK;
non terminal FOR_BLOCK;
non terminal REPEAT_BLOCK;
non terminal INICIO;

start with S;

S ::= INICIO: inicio {: System.out.println(inicio); :}
  ;

INICIO ::=
  PROGRAM_BLOCK: program
  VAR_BLOCK: var
  FUNC_PROC_BLOCK: functions
  MAIN_BLOCK: main
  {:
    // program es obligatorio, seria la raiz
    Node raiz = (Node) program;

    // var es opcional
    if (var != null) {
      raiz.add(var);
    }

    // functions es opcional
    if (functions != null) {
      raiz.add(functions);
    }

    // main es opcional ('begin end.')
    if (main != null) {
      raiz.add(main);
    }

    RESULT = raiz;
  :}
  ;

PROGRAM_BLOCK ::=
  PROGRAM: program ID: id PUNTOCOMA
  {:
    Node res = new Node<>(id);
    RESULT = res;
  :}
  ;

FUNC_PROC_BLOCK ::=
  FUNC_DECL: decl FUNC_PROC_BLOCK: more
  {:
    Node res = new Node<>("func_proc_decl");
    if (more != null) {
      res.join((Node) more);
    }
    RESULT = res;
  :}
  | PROC_DECL: decl FUNC_PROC_BLOCK: more
  {:
    Node res = new Node<>("func_proc_decl");
    if (more != null) {
      res.join((Node) more);
    }
    RESULT = res;
  :}
  |
  ;

FUNC_DECL ::=
  FUNCTION: func ID: id PAR_IZQ MAYBE_ARGS: args PAR_DER DOSPUNTOS TYPE: returnType PUNTOCOMA
  VAR_BLOCK: vars
  BEGIN
    STMNT_LIST: stmntList
  END PUNTOCOMA
  {:
    Node res = new Node<>(func);
    res.add(id);
    res.add(returnType);
    res.add(args);
    res.add(vars);
    res.add(stmntList);
    RESULT = res;
  :}
  ;

PROC_DECL ::=
  PROCEDURE: proc ID: id PAR_IZQ MAYBE_ARGS: args PAR_DER PUNTOCOMA
  VAR_BLOCK: vars
  BEGIN
    STMNT_LIST: stmntList
  END PUNTOCOMA
  {:
    Node res = new Node<>(proc);
    res.add(id);
    res.add(args);
    res.add(vars);
    res.add(stmntList);
    RESULT = res;
  :}
  ;

VAR_BLOCK ::=
  VAR VARS: vars {: RESULT = vars; :}
  |
  ;

VARS ::=
  IDS: ids DOSPUNTOS TYPE: type PUNTOCOMA VARS: moreVars
  {:
    Node vars = new Node<>("vars");
    Node nType = new Node<>(type);
    nType.join((Node) ids);
    vars.add(nType);
    vars.join((Node) moreVars);
    RESULT = vars;
  :}
  | IDS: ids DOSPUNTOS TYPE: type PUNTOCOMA
  {:
    Node vars = new Node<>("vars");
    Node nType = new Node<>(type);
    nType.join((Node) ids);
    vars.add(nType);
    RESULT = vars;
  :}
  ;

MAYBE_ARGS ::=
  ARGS: args {: RESULT = args; :}
  |
  ;

ARGS ::=
  IDS: ids DOSPUNTOS TYPE: type PUNTOCOMA ARGS: moreArgs
  {:
    Node args = new Node<>("args");
    Node nType = new Node<>(type);
    nType.join((Node) ids);
    args.add(nType);
    args.join((Node) moreArgs);
    RESULT = args;
  :}
  | IDS: ids DOSPUNTOS TYPE: type
  {:
    Node args = new Node<>("args");
    Node nType = new Node<>(type);
    nType.join((Node) ids);
    args.add(nType);
    RESULT = args;
  :}
  ;

IDS ::=
  ID: id COMA IDS: ids
  {:
    Node nodo = new Node<>(id);
    nodo.join((Node) ids);
    RESULT = nodo;
  :}
  | ID: id {: RESULT = new Node<>(id); :}
  ;

TYPE ::=
  INTEGER: kwinteger {: RESULT = kwinteger; :}
  | REAL: kwreal {: RESULT = kwreal; :}
  | BOOLEAN: kwboolean {: RESULT = kwboolean; :}
  | CHAR: kwchar {: RESULT = kwchar; :}
  | STRING: kwstring {: RESULT = kwstring; :}
  ;

MAIN_BLOCK ::=
  BEGIN STMNT_LIST: stmtList END PUNTO {: RESULT = stmtList; :}
  ;

STMNT_LIST ::=
  STATEMENT: stmnt PUNTOCOMA STMNT_LIST: stmntList
  {:
    Node nodo = (Node) stmnt;
    if (stmntList != null) {
      nodo.join((Node) stmntList);
    }
    RESULT = nodo;
  :}
  |
  ;

STMNT_FUNC ::=
  ID: id PAR_IZQ EXPR_LIST: exprList PAR_DER
  {:
    Node res = new Node<>("func_call");
    res.add(id);
    res.add(exprList);
    RESULT = res;
  :}
  | FUNC_READ: func PAR_IZQ EXPR_LIST: exprList PAR_DER
  {:
    Node res = new Node<>("func_call");
    res.add(func);
    res.add(exprList);
    RESULT = res;
  :}
  | FUNC_WRITE: func PAR_IZQ EXPR_LIST: exprList PAR_DER
  {:
    Node res = new Node<>("func_call");
    res.add(func);
    res.add(exprList);
    RESULT = res;
  :}
  ;

STATEMENT ::=
  | OPEN_STATEMENT: o {: RESULT = o; :}
  | IF: kwif EXPR: expr THEN CLOSED_STATEMENT: closed1 ELSE CLOSED_STATEMENT: closed2
  {:
    Node res = new Node<>(kwif);
    res.add(expr);
    res.add(closed1);
    res.add(closed2);
    RESULT = res;
  :}
  | WHILE_BLOCK: w {: RESULT = w; :}
  | FOR_BLOCK: f {: RESULT = f; :}
  | REPEAT_BLOCK: r {: RESULT = r; :}
  | COMPOUND_STATEMENT: c {: RESULT = c; :}
  | SIMPLE_STATEMENT: s {: RESULT = s; :}
  ;

COMPOUND_STATEMENT ::=
  BEGIN STMNT_LIST: stmntList END
  {:
    RESULT = stmntList;
  :}
  ;

SIMPLE_STATEMENT ::=
  ID: id ASIGNACION: asign EXPR: expr
  {:
    Node res = new Node<>(asign);
    res.add(id);
    res.add(expr);
    RESULT = res;
  :}
  | STMNT_FUNC: stmntFunc {: RESULT = stmntFunc; :}
  ;

OPEN_STATEMENT ::=
  IF: kwif EXPR: expr THEN: then STATEMENT: stmnt
  {:
    Node res = new Node<>(kwif);
    res.add(expr);
    Node nThen = new Node<>(then);
    nThen.add(stmnt);
    res.add(nThen);
    RESULT = res;
  :}
  | IF: kwif EXPR: expr THEN CLOSED_STATEMENT: closed ELSE OPEN_STATEMENT: open
  {:
    // las intrucciones de then y else al final
    Node res = new Node<>(kwif);
    res.add(expr);
    res.add(closed);
    res.add(open);
    RESULT = res;
  :}
  ;

CLOSED_STATEMENT ::=
  IF: kwif EXPR: expr THEN CLOSED_STATEMENT: closed1 ELSE CLOSED_STATEMENT: closed2
  {:
    // las instrucciones de then y else al final
    Node res = new Node<>(kwif);
    res.add(expr);
    res.add(closed1);
    res.add(closed2);
    RESULT = res;
  :}
  | SIMPLE_STATEMENT: simpleStmnt {: RESULT = simpleStmnt; :}
  ;

WHILE_BLOCK ::=
  WHILE: kwwhile EXPR: expr DO STATEMENT: stmnt
  {:
    // las instrucciones que se ejecutan van al final de children
    Node res = new Node<>(kwwhile);
    res.add(expr);
    res.add(stmnt);
    RESULT = res;
  :}
  ;

FOR_BLOCK ::=
  FOR: kwfor ID: id ASIGNACION: asign EXPR: expr TO FACTOR: factor DO STATEMENT: stmnt
  {:
    // las instrucciones que se ejecutan van al final de children
    Node res = new Node<>(kwfor);
    Node asig = new Node<>(asign);
    asig.add(id);
    asig.add(expr);
    Node to = (Node) factor;
    res.add(asig);
    res.add(to);
    res.add(stmnt);
    RESULT = res;
  :}
  ;

REPEAT_BLOCK ::=
  REPEAT: repeat STATEMENT: stmnt UNTIL: kwuntil EXPR: expr
  {:
    // las instrucciones que se ejecutan van al final de children
    Node res = new Node<>(repeat);
    Node until = new Node<>(kwuntil);
    until.add(expr);
    res.add(until);
    res.add(stmnt);
    RESULT = res;
  :}
  ;

EXPR ::=
  SIMPLE_EXPR: simpleExpr {: RESULT = simpleExpr; :}
  | SIMPLE_EXPR: simpleExpr1 OP_RELACIONAL: opRel SIMPLE_EXPR: simpleExpr2
  {:
    Node res = new Node<>(opRel);
    res.add(simpleExpr1);
    res.add(simpleExpr2);
    RESULT = res;
  :}
  ;

EXPR_LIST ::=
  EXPR: expr COMA EXPR_LIST: exprList
  {:
    Node nodo = (Node) expr;
    nodo.join((Node) exprList);
    RESULT = nodo;
  :}
  | EXPR: expr {: RESULT = expr; :}
  ;

SIMPLE_EXPR ::=
  TERMINO: termino {: RESULT = termino; :}
  | OP_SUMA: opSuma TERMINO: termino {: Node op = new Node<>(opSuma); op.add(termino); RESULT = op; :}
  | SIMPLE_EXPR: simpleExpr OP_SUMA: opSuma TERMINO: termino
  {:
    Node op = new Node<>(opSuma);
    op.add(simpleExpr);
    op.add(termino);
    RESULT = op;
  :}
  ;

TERMINO ::=
  FACTOR: factor {: RESULT = factor; :}
  | TERMINO: termino OP_MULT: opMult FACTOR: factor
  {:
    Node mult = new Node<>(opMult);
    mult.add(termino);
    mult.add(factor);
    RESULT = mult;
  :}
  ;

FACTOR ::=
  ID: id {: RESULT = new Node<>(id); :}
  | STMNT_FUNC: stmntFunc {: RESULT = stmntFunc; :}
  | CONST_VAL: val {: RESULT = new Node<>(val); :}
  | PAR_IZQ EXPR: expr PAR_DER {: RESULT = expr; :}
  | NOT: n FACTOR: factor {: Node not = new Node<>(n); not.add(factor); RESULT = not; :}
  ;

CONST_VAL ::=
  NUM_INTEGER: num {: RESULT = num; :}
  | NUM_FLOAT: num {: RESULT = num; :}
  | CONSTCHAR: constchar {: RESULT = constchar; :}
  | CONSTSTR: string {: RESULT = string; :}
  | CONSTBOOL: bool {: RESULT = bool; :}
  | NIL: nil {: RESULT = null; :}
  ;
